# Trifle

The Trifle SDK is designed to facilitate app-level secure communication between client apps and backend services even across TLS termination points. The SDK establishes a standardized framework that ensures:
- Backend services can verify the authenticity and integrity of the client data
- Availability of authentic client app signals to the backend services

These security guarantees apply on top of transport level security such as TLS and allow application of data safety policies at a finer granularity.

The Trifle SDK integrates with a provided Certificate Authority that provisions a Trifle-formatted certificate to the client app. This certificate captures curently only client app identity. 
 
There are two main components to Trifle SDK:
- Standardized convenience APIs that provide recommended established security measures on given native platforms, abstracting away implementation complexities.
- Standardize message formatting for security artifacts including certificates, ciphertexts and signatures.

Trifle SDK is implemented on client side in iOS and Android and on server side in Kotlin. 



## Swift SDK Usage 

```swift
// App start up
let trifle = try Trifle(reverseDomain: abc)

// Check if a key already exists.
// If no key exists, generate a public key pair
let keyHandle = try trifle.generateKeyHandle()
                
// Storing keys. Keys are codable.
let encoder = JSONEncoder()
let jsonKeyHandle = try encoder.encode(keyHandle)

// Load the key from storage when we need to use it
let decoder = JSONDecoder()
let decoded = try decoder.decode(TrifleKeyHandle.self, from: jsonKeyHandle)

// Check the validity of loaded key
let valid = trifle.isValid(keyHandle: keyHandle)

// Destroy key that is no longer in use or is invalid
let status = trifle.delete(keyHandle: keyHandle)
        
// Check if loaded key already has a cert. If yes, skip to checking for cert validity
// Else if key does not have a cert OR if a new cert must be generated (eg because of existing
// cert is already expired, or app needs to re-attest, app is re-installed, app is restored
// from backup, ... etc)

// Create cert request
let certReq = try trifle.generateMobileCertificateRequest(entity: entity, keyHandle: keyHandle)

// Serialize to proto to be sent over wire
let encoded = try certReq.serialize()

// Send certificate request to Certificate Authority endpoint. Response will be [Data]
let response: [Data]

// Iterate over each Data to convert to TrifleCertificate
let certs = try response.map({ try TrifleCertificate.deserialize(data: $0) })


// certs is an array of certificates where [0] will be device certificate
// and the rest of the elements will be intermediate chain.

// Check if app has the root cert of Certificate Authority (CA). 

// Validate cert matches the certificate request (so generated key) 
// and the root (so it has been generated by the right CA).
let isValid = certs[0].verify(
            certificateRequest: certRequest,
            intermediateTrifleChain: certs,
            rootTrifleCertificate: root)

// Once it passes validation, certReq is no longer needed and it can be deleted
// Store cert along with the respective keyHandle
        
// To check only for the validity of a stored cert, you can do either of below choices
// Option 1 is a more complete check of the device cert and the full chain
isValid = certs[0].verify(intermediateChain: certs )

// option 2 only checks the validity of the device cert
isValid = certs[0].verify(intermediateChain: [] )

// Sign the data
let trifleSignedData = try trifle.createSignedData(
                                        data: dataThatIsSigned,
                                        keyHandle: keyHandle,
                                        certificates: certs )

// Serialize to proto to be sent over wire
let encodedTrifleSignedDataProto = try trifleSignedData.serialize()
```

## Android SDK Usage 

```kotlin
// Check if a key already exists.
// If no key exists, generate a public key pair
var keyHandle =  TrifleApi.generateKeyHandle(alias: abc)
                
// Storing keys. Keys are codable.
val encoder = Gson()
let jsonKeyHandle = try encoder.toJson(keyHandle)

// Load the key from storage when we need to use it

// Check the validity of loaded key
// TBD trifleApi.isValid(keyHandle: keyHandle)

// Destroy key that is no longer in use or is invalid
// TBD trifleApi.delete(keyHandle: keyHandle)
        
// Check if loaded key already has a cert. If yes, skip to checking for cert validity
// Else if key does not have a cert OR if a new cert must be generated (eg because of existing
// cert is already expired, or app needs to re-attest, app is re-installed, app is restored
// from backup, ... etc)

// Create cert request
val certReq = TrifleApi.generateMobileCertificateRequest(entity = entity, keyHandle = keyHandle)

// Serialize to proto to be sent over wire

// Send certificate request to Certificate Authority endpoint. Response will be [Data]
// Iterate over each Data to convert to TrifleCertificate

// certs is an array of certificates where [0] will be device certificate
// and the rest of the elements will be intermediate chain.

// Check if app has the root cert of Certificate Authority (CA). 

// Validate cert matches the certificate request (so generated key) 
// and the root (so it has been generated by the right CA).
// TBD var isValid = TrifleApi.verify(csr, certs, anchor)

// Once it passes validation, certReq is no longer needed and it can be deleted
// Store cert along with the respective keyHandle
        
// To check only for the validity of a stored cert, you can do either of below choices
// Option 1 is a more complete check of the device cert and the full chain
// TBD var isValid = TrifleApi.verify(certs)

// option 2 only checks the validity of the device cert
// TBD var isValid = TrifleApi.verify(certs)

// Sign the data
let trifleSignedData = TrifleApi.createSignedData(
                                        dataThatIsSigned, 
                                        keyHandle, 
                                        certs )

// Serialize to proto to be sent over wire
val encodedTrifleSignedDataProto = trifleSignedData.serialize()
```

## Key Lifecycle

TBD


## Cert Lifecycle

TBD

## Roadmap
The Trifle roadmap includes some of the following features:
- Backend services are able to exchange private messages with the client app
- Inclusion of client provided attributes and/or user information in the certificate
- Extending client SDK to Web
